package Shield
import HashMap
import LinkedList
import EventHelper
import ErrorHandling

/* Creates an instance of a shield around a unit that
absorbs taken damage. A callback, that's be executed
on each DAMAGED event before absorbing, can be passed. */


let shieldedUnits = new HashMap<unit, LinkedList<Shield>>


interface IOnShieldAbsorbCallback
	function call(Shield shield, real takenDamage, real absorbedDamage)


public class Shield
	private unit target
	private real amount
	private real factor
	private IOnShieldAbsorbCallback absorbCallback

	construct(unit target, real amount, real factor, IOnShieldAbsorbCallback cb)
		this.target = target
		setAmount(amount)
		setFactor(factor)
		absorbCallback = cb
		if not shieldedUnits.has(target)
			shieldedUnits.put(target, new LinkedList<Shield>)
		shieldedUnits.get(target).add(this)

	ondestroy
		let shieldStack = shieldedUnits.get(target)
		shieldStack.remove(this)
		if shieldStack.isEmpty()
			destroy shieldStack
			shieldedUnits.remove(target)
		if absorbCallback != null
			destroy absorbCallback

	function setAmount(real amount)
		if amount <= 0
			error("Shield cannot absorb 0 or less damage")
		this.amount = amount

	/** A part of the taken damage that will be absorbed. 1.0 - the shield absorbs all the damage. */
	function setFactor(real factor)
		if factor <= 0
			error("Shield cannot absorb 0% of damage")
		this.factor = factor

	function getDurability() returns real
		return amount

	function getFactor() returns real
		return factor

	function isBroken() returns bool
		return amount == 0

	protected function absorb(real damage) returns real
		if not isBroken()
			let maxAbsorb = damage * factor
			real absorbedDamage
			if amount > maxAbsorb
				amount -= maxAbsorb
				absorbedDamage = maxAbsorb
			else
				absorbedDamage = amount
				amount = 0
			if absorbCallback != null
				absorbCallback.call(this, damage, absorbedDamage)
			return absorbedDamage
		return 0


init
	CreateTrigger()..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DAMAGED)
	..addAction() ->
		let target = EventData.getTriggerUnit()
		let shields = shieldedUnits.get(target)
		var damage = EventData.getEventDamage()
		if shieldedUnits.has(target)
			for i = shields.size() - 1 downto 0
				let shield = shields.get(i)
				if not shield.isBroken()
					damage = damage - shield.absorb(damage)
					if damage <= 0.0001
						EventData.setDamage(0)
						break
					else
						EventData.setDamage(damage)


init
	CreateTrigger()..registerAnyUnitEvent(EVENT_PLAYER_UNIT_DEATH)
	..addAction() ->
		let u = EventData.getDyingUnit()
		if not u.isType(UNIT_TYPE_HERO) and shieldedUnits.has(u)
			destroy shieldedUnits.getAndRemove(u)