package RunedAlias
import ItemObjEditing
import ObjectIdGenerator

import ClosureEvents
import ClosureTimers
import LinkedList


/* An item alias is an item that copies all the fields of a specific item,
except its ability list, and with "Use Automatically When Aquired" field
set to "true". When a unit pick up an alias the trigger gives the unit
the actual item. When a unit drops an item, the item is removed and the actual
alias is created.
Such aliases are used to bypass the error message when a unit is trying
to pick up an item with no empty inventory slots. For example, when a hero
needs to pick up a stackable item with no empty slot but with such an item
in the inventory, or when an item's gonna be combined with other items but
it can't be done becouse of the annoying mechanic. */


public abstract class RunedAlias
	protected RunedAlias next = null
	protected RunedAlias prev = null

	protected static RunedAlias first = null

	abstract function call(unit u, item givenItem)

	ondestroy
		if first == this
			first = next
		else
			prev.next = next
		if next != null
			next.prev = prev

	static function onActualItem(RunedAlias cb) returns RunedAlias
		if RunedAlias.first == null
			cb.next = RunedAlias.first
			RunedAlias.first.prev = cb
		RunedAlias.first = cb
		return cb

	// Compiletime 

	// Transfered data
	protected static let actualItemIds = compiletime(new LinkedList<int>)
	protected static let aliasItemIds = compiletime(new LinkedList<int>)

	abstract static class BuildCallback
		abstract function call(ItemDefinition def, bool isAlias)

	static function build(ItemDefinition actualItemDef, ItemDefinition aliasItemDef, BuildCallback buildCb)
		buildCb.call(actualItemDef, false)
		buildCb.call(aliasItemDef, true)
		actualItemDef.setUseAutomaticallyWhenAcquired(false)
		aliasItemDef..setUseAutomaticallyWhenAcquired(true)
		..setAbilities("")
		actualItemIds.add(actualItemDef.getNewId())
		aliasItemIds.add(aliasItemDef.getNewId())
		destroy buildCb
	
	static function build(int actualItemId, int aliasItemId, BuildCallback buildCb)
		build(new ItemDefinition(actualItemId, 'afac'), new ItemDefinition(aliasItemId, 'afac'), buildCb)
	
	static function build(int actualItemId, BuildCallback buildCb)
		build(actualItemId, ITEM_ID_GEN.next(), buildCb)

	static function build(BuildCallback buildCb)
		build(ITEM_ID_GEN.next(), ITEM_ID_GEN.next(), buildCb)


init
	for i = 0 to RunedAlias.actualItemIds.size() - 1
		createItem(RunedAlias.actualItemIds.get(i), ZERO2).remove()
		createItem(RunedAlias.aliasItemIds.get(i), ZERO2).remove()

	EventListener.add(EVENT_PLAYER_UNIT_PICKUP_ITEM) () ->
		let aliasItem = EventData.getManipulatedItem()
		let aliasItemId = aliasItem.getTypeId()
		if RunedAlias.aliasItemIds.has(aliasItemId)
			let u = EventData.getTriggerUnit()
			let pos = aliasItem.getPos()
			let p = aliasItem.getPlayer()
			let charges = aliasItem.getCharges()
			aliasItem.remove()
			let isInventoryFull = u.isInventoryFull()
			let index = RunedAlias.aliasItemIds.indexOf(aliasItemId)
			let actualItemId = RunedAlias.actualItemIds.get(index)
			let newItem = not isInventoryFull ? u.addItemById(actualItemId) : createItem(actualItemId, pos)
			newItem..setPlayer(p, true)
			..setCharges(charges)
			var cb = RunedAlias.first
			while cb != null
				cb.call(u, newItem)
				cb = cb.next
			if newItem.getTypeId() != 0 and isInventoryFull
				newItem.remove()
				createItem(aliasItemId, pos)
				..setPlayer(p, true)
				..setCharges(charges)


	EventListener.add(EVENT_PLAYER_UNIT_DROP_ITEM) ->
		let droppedItem = EventData.getManipulatedItem()
		let droppedItemId = droppedItem.getTypeId()
		if RunedAlias.actualItemIds.has(droppedItemId)
			nullTimer() () ->
				let p = droppedItem.getPlayer()
				let pos = droppedItem.getPos()
				let charges = droppedItem.getCharges()
				droppedItem.remove()
				let index = RunedAlias.actualItemIds.indexOf(droppedItemId)
				createItem(RunedAlias.aliasItemIds.get(index), pos)
				..setPlayer(p, true)
				..setCharges(charges)
