package RunedAlias
import ItemObjEditing
import ObjectIdGenerator

import ClosureEvents
import ClosureTimers
import LinkedListModule
import LinkedList


/* An item alias is an item that copies all the fields of a specific item,
except its ability list, and with "Use Automatically When Aquired" field
set to "true". When a unit pick up an alias the trigger gives the unit
the actual item. When a unit drops an item, the item is removed and the actual
alias is created.
Such aliases are used to bypass the error message when a unit is trying
to pick up an item with no empty inventory slots. For example, when a hero
needs to pick up a stackable item with no empty slot but with such an item
in the inventory, or when an item's gonna be combined with other items but
it can't be done becouse of the annoying mechanic. */


let actualItemIds = compiletime(new LinkedList<int>)
let aliasItemIds = compiletime(new LinkedList<int>)

interface IItemWithAliasCallback
	function call(ItemDefinition def, bool isAlias)

function buildItemWithAlias(ItemDefinition actualItemDef, ItemDefinition aliasItemDef, IItemWithAliasCallback cb)
	cb.call(actualItemDef, false)
	cb.call(aliasItemDef, true)
	actualItemDef.setUseAutomaticallyWhenAcquired(false)
	aliasItemDef..setUseAutomaticallyWhenAcquired(true)
	..setAbilities("")
	actualItemIds.add(actualItemDef.getNewId())
	aliasItemIds.add(aliasItemDef.getNewId())
	destroy cb

public function buildItemWithAlias(int actualItemId, int aliasItemId, IItemWithAliasCallback cb)
	buildItemWithAlias(new ItemDefinition(actualItemId, 'afac'), new ItemDefinition(aliasItemId, 'afac'), cb)

public function buildItemWithAlias(int actualItemId, IItemWithAliasCallback cb)
	buildItemWithAlias(actualItemId, ITEM_ID_GEN.next(), cb)


public function registerItemAlias(int actualItemId, int aliasItemId)
	if not actualItemIds.has(actualItemId)
		actualItemIds.add(actualItemId)
		aliasItemIds.add(aliasItemId)
	else
		let i = actualItemIds.indexOf(actualItemId)
		aliasItemIds.set(i, aliasItemId)


abstract class AliasedItemGivenCallback
	use LinkedListModule
	abstract function call(unit u, item givenItem)

public function onAliasedItemGiven(AliasedItemGivenCallback _cb)


init
	for i = 0 to actualItemIds.size() - 1
		createItem(actualItemIds.get(i), ZERO2).remove()
		createItem(aliasItemIds.get(i), ZERO2).remove()

	EventListener.add(EVENT_PLAYER_UNIT_PICKUP_ITEM) () ->
		let aliasItem = EventData.getManipulatedItem()
		let aliasItemId = aliasItem.getTypeId()
		if aliasItemIds.has(aliasItemId)
			let u = EventData.getTriggerUnit()
			let pos = aliasItem.getPos()
			let p = aliasItem.getPlayer()
			let charges = aliasItem.getCharges()
			aliasItem.remove()
			let isInventoryFull = u.isInventoryFull()
			let index = aliasItemIds.indexOf(aliasItemId)
			let actualItemId = actualItemIds.get(index)
			let newItem = not isInventoryFull ? u.addItemById(actualItemId) : createItem(actualItemId, pos)
			newItem..setPlayer(p, true)
			..setCharges(charges)
			for cb in AliasedItemGivenCallback
				cb.call(u, newItem)
			if newItem.getTypeId() != 0 and isInventoryFull
				newItem.remove()
				createItem(aliasItemId, pos)
				..setPlayer(p, true)
				..setCharges(charges)

	EventListener.add(EVENT_PLAYER_UNIT_DROP_ITEM) ->
		let droppedItem = EventData.getManipulatedItem()
		let droppedItemId = droppedItem.getTypeId()
		if actualItemIds.has(droppedItemId)
			nullTimer() () ->
				let p = droppedItem.getPlayer()
				let pos = droppedItem.getPos()
				let charges = droppedItem.getCharges()
				droppedItem.remove()
				let index = actualItemIds.indexOf(droppedItemId)
				createItem(aliasItemIds.get(index), pos)
				..setPlayer(p, true)
				..setCharges(charges)
