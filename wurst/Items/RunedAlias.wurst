package RunedAlias
import ItemObjEditing
import ObjectIds
import ObjectIdGenerator

import HashMap
import ClosureEvents
import ClosureTimers
import LinkedListModule


/* An item alias is an item that clones all the fields of a specific item,
except its ability list, and with "Use Automatically When Aquired" field
set to "true". When a unit pick up an alias the trigger gives the unit
the actual item. When a unit drops an item, the item is removed and the actual
alias is created.
Such aliases are used to bypass the error message when a unit is trying
to pick up an item with no empty inventory slots. For example, when a hero
needs to pick up a stackable item with no empty slot but with such an item
in the inventory, or when an item's gonna be combined with other items but
it can't be done becouse of the annoying mechanic. */


constant TRANSFER_ITEM_ID = compiletime(ITEM_ID_GEN.next())

let transferItemDef = not compiletime ? null : new ItemDefinition(TRANSFER_ITEM_ID, 'afac')
	..setName("")
	..setDescription("")
	..setTooltipBasic("")
	..setTooltipExtended("")
let maxCouplesPerField = 127
var currentField = 0
var abilList = ""


function addTransferData(int actualItemId, int aliasItemId)
	abilList += actualItemId.toRawCode() + aliasItemId.toRawCode()
	switch currentField
		case 0
			transferItemDef.setName(abilList)
		case 1
			transferItemDef.setDescription(abilList)
		case 2
			transferItemDef.setTooltipBasic(abilList)
		case 3
			transferItemDef.setTooltipExtended(abilList)
	if (abilList.length() / 8).toInt() == maxCouplesPerField
		currentField++
		abilList = ""


interface IItemWithAliasCallback
	function call(ItemDefinition def, bool isAlias)


function buildItemWithAlias(ItemDefinition actualItemDef, ItemDefinition aliasItemDef, IItemWithAliasCallback cb)
	cb.call(actualItemDef, false)
	cb.call(aliasItemDef, true)
	actualItemDef.setUseAutomaticallyWhenAcquired(false)
	aliasItemDef..setUseAutomaticallyWhenAcquired(true)
	..setAbilities("")
	addTransferData(actualItemDef.getNewId(), aliasItemDef.getNewId())
	destroy cb

public function buildItemWithAlias(int actualItemId, int aliasItemId, IItemWithAliasCallback cb)
	buildItemWithAlias(new ItemDefinition(actualItemId, 'afac'), new ItemDefinition(aliasItemId, 'afac'), cb)

public function buildItemWithAlias(int actualItemId, IItemWithAliasCallback cb)
	buildItemWithAlias(actualItemId, ITEM_ID_GEN.next(), cb)


abstract class AliasedItemGivenCallback
	use LinkedListModule
	abstract function call(unit u, item givenItem)

public function onAliasedItemGiven(AliasedItemGivenCallback _cb)


init
	let actualItemIds = new IterableMap<int, int>
	let aliasItemIds = new IterableMap<int, int>
	let transferItem = createItem(TRANSFER_ITEM_ID, ZERO2)
	for currentField = 3 downto 0
		switch currentField
			case 0
				abilList = transferItem.getName()
			case 1
				abilList = transferItem.getDescription()
			case 2
				abilList = transferItem.getTooltip()
			case 3
				abilList = transferItem.getExtendedTooltip()
		for i = 0 to abilList.length() - 1 step 8
			let itemId = abilList.substring(i, i + 4).fromRawCode()
			let aliasId = abilList.substring(i + 4, i + 8).fromRawCode()
			actualItemIds.put(itemId, aliasId)
			aliasItemIds.put(aliasId, itemId)
	transferItem.remove()

	// preload
	actualItemIds.forEach() (key, value) ->
		createItem(key, ZERO2).remove()
		createItem(value, ZERO2).remove()

	EventListener.add(EVENT_PLAYER_UNIT_PICKUP_ITEM) () ->
		let _item = EventData.getManipulatedItem()
		let aliasId = _item.getTypeId()
		if aliasItemIds.has(aliasId)
			let u = EventData.getTriggerUnit()
			let pos = _item.getPos()
			let p = _item.getPlayer()
			let charges = _item.getCharges()
			_item.remove()
			let isInventoryFull = u.isInventoryFull()
			let newItem = not isInventoryFull ? u.addItemById(aliasItemIds.get(aliasId)) : createItem(aliasItemIds.get(aliasId), pos)
			newItem..setPlayer(p, true)
			..setCharges(charges)
			for cb in AliasedItemGivenCallback
				cb.call(u, newItem)
			if newItem.getTypeId() != 0 and isInventoryFull
				newItem.remove()
				createItem(aliasId, pos)
				..setPlayer(p, true)
				..setCharges(charges)

	EventListener.add(EVENT_PLAYER_UNIT_DROP_ITEM) ->
		let _item = EventData.getManipulatedItem()
		let itemId = _item.getTypeId()
		if actualItemIds.has(itemId)
			nullTimer() () ->
				let p = _item.getPlayer()
				let pos = _item.getPos()
				let charges = _item.getCharges()
				_item.remove()
				createItem(actualItemIds.get(itemId), pos)
				..setPlayer(p, true)
				..setCharges(charges)
